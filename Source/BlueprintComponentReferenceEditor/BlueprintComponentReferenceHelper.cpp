// Copyright 2024, Aquanox.

#include "BlueprintComponentReferenceHelper.h"

#include "BlueprintComponentReferenceEditor.h"
#include "Engine/World.h"
#include "GameFramework/Pawn.h"
#include "Kismet2/ComponentEditorUtils.h"
#include "Misc/CoreDelegates.h"
#include "Modules/ModuleManager.h"
#include "UObject/UObjectIterator.h"
#include "Misc/EngineVersionComparison.h"

DEFINE_LOG_CATEGORY(LogComponentReferenceEditor);

#define LOCTEXT_NAMESPACE "BlueprintComponentReference"

#if UE_VERSION_OLDER_THAN(5,4,0)
inline static FName GetFNameSafe(const UObject* InField)
{
	if (IsValid(InField))
	{
		return InField->GetFName();
	}
	return NAME_None;
}
#endif

inline static FString BuildComponentInfo(const UActorComponent* Obj)
{
	FStringBuilderBase Base;
	Base.Appendf(TEXT("%p:%s"), Obj, *Obj->GetName());
	Base.Appendf(TEXT(" Flags=%d"), Obj->GetFlags());
	Base.Appendf(TEXT(" Method=%s"), *StaticEnum<EComponentCreationMethod>()->GetNameStringByValue((int64)Obj->CreationMethod));
	return Base.ToString();
}

UActorComponent* FComponentInfo::GetComponentTemplate() const
{
	return Object.Get();
}

UClass* FComponentInfo::GetComponentClass() const
{
	return Object.IsValid() ? Object->GetClass() : nullptr;
}

FName FComponentInfo::GetNodeID() const
{
	FName ItemName = GetVariableName();
	if (ItemName == NAME_None)
	{
		UActorComponent* ComponentTemplateOrInstance = GetComponentTemplate();
		if (ComponentTemplateOrInstance != nullptr)
		{
			ItemName = ComponentTemplateOrInstance->GetFName();
		}
	}
	return ItemName;
}

FName FComponentInfo::GetVariableName() const
{
	FName VariableName = NAME_None;

	USCS_Node* SCS_Node = GetSCSNode();
	UActorComponent* ComponentTemplate = GetComponentTemplate();

	if (IsInstancedComponent() && (SCS_Node == nullptr) && (ComponentTemplate != nullptr))
	{
		if (ComponentTemplate->GetOwner())
		{
			SCS_Node = FBlueprintComponentReferenceHelper::FindSCSNodeForInstance(ComponentTemplate, ComponentTemplate->GetOwner()->GetClass());
		}
	}

	if (SCS_Node)
	{
		// Use the same variable name as is obtained by the compiler
		VariableName = SCS_Node->GetVariableName();
	}
	else if (ComponentTemplate)
	{
		// Try to find the component anchor variable name (first looks for an exact match then scans for any matching variable that points to the archetype in the CDO)
		VariableName = FComponentEditorUtils::FindVariableNameGivenComponentInstance(ComponentTemplate);
	}

	return VariableName;
}

FName FComponentInfo::GetObjectName() const
{
	if (UActorComponent* ComponentTemplate = GetComponentTemplate())
	{
		return ComponentTemplate->GetFName();
	}
	return NAME_None;
}

FText FComponentInfo::GetDisplayText() const
{
	FName VariableName = GetVariableName();
	UActorComponent* ComponentTemplate = GetComponentTemplate();

	UBlueprint* Blueprint = GetBlueprint();
	UClass* VariableOwner = (Blueprint != nullptr) ? Blueprint->SkeletonGeneratedClass : nullptr;
	FProperty* VariableProperty = FindFProperty<FProperty>(VariableOwner, VariableName);

	bool bHasValidVarName = (VariableName != NAME_None);

	bool bIsArrayVariable = bHasValidVarName
		&& (VariableOwner != nullptr)
		&& VariableProperty && VariableProperty->IsA<FArrayProperty>();

	FString Value;

	// Only display SCS node variable names in the tree if they have not been autogenerated
	if (bHasValidVarName && !bIsArrayVariable)
	{
		if (IsNativeComponent())
		{
			FStringFormatNamedArguments Args;
			Args.Add(TEXT("VarName"), VariableProperty && VariableProperty->IsNative() ? VariableProperty->GetDisplayNameText().ToString() : VariableName.ToString());
			Args.Add(TEXT("CompName"), ComponentTemplate->GetName());
			Value = FString::Format(TEXT("{VarName} ({CompName})"), Args);
		}
		else
		{
			Value = VariableName.ToString();
		}
	}
	else if ( ComponentTemplate != nullptr )
	{
		Value = ComponentTemplate->GetFName().ToString();
	}
	else
	{
		FString UnnamedString = LOCTEXT("UnnamedToolTip", "Unnamed").ToString();
		FString NativeString = IsNativeComponent() ? LOCTEXT("NativeToolTip", "Native ").ToString() : TEXT("");

		if (ComponentTemplate != NULL)
		{
			Value = FString::Printf(TEXT("[%s %s%s]"), *UnnamedString, *NativeString, *ComponentTemplate->GetClass()->GetName());
		}
		else
		{
			Value = FString::Printf(TEXT("[%s %s]"), *UnnamedString, *NativeString);
		}
	}

	return FText::FromString(Value);
}

FText FComponentInfo::GetTooltipText() const
{
	return FText::GetEmpty();
}

UBlueprint* FComponentInfo::GetBlueprint() const
{
	if (const USCS_Node* SCS_Node = GetSCSNode())
	{
		if (const USimpleConstructionScript* SCS = SCS_Node->GetSCS())
		{
			return SCS->GetBlueprint();
		}
	}
	else if (const UActorComponent* ActorComponent = GetComponentTemplate())
	{
		if (const AActor* Actor = ActorComponent->GetOwner())
		{
			return UBlueprint::GetBlueprintFromClass(Actor->GetClass());
		}
	}

	return nullptr;
}


USCS_Node* FComponentInfo::GetSCSNode() const
{
	return nullptr;
}

EBlueprintComponentReferenceMode FComponentInfo::GetDesiredMode() const
{
	return !GetVariableName().IsNone() ? EBlueprintComponentReferenceMode::Property : EBlueprintComponentReferenceMode::Path;
}


FComponentInfo_Default::FComponentInfo_Default(USCS_Node* SCSNode, bool bInIsInherited) : SCSNode(SCSNode)
{
	Object = SCSNode->ComponentTemplate;
}

FComponentInfo_Default::FComponentInfo_Default(UActorComponent* Component, bool bInherited)
{
	Object = Component;

	AActor* Owner = Component->GetOwner();
	if (Owner != nullptr)
	{
		ensureMsgf(Owner->HasAnyFlags(RF_ClassDefaultObject|RF_ArchetypeObject), TEXT("Use a different node class for instanced components"));
	}
}

bool FComponentInfo_Default::IsNativeComponent() const
{
	return GetSCSNode() == nullptr && GetComponentTemplate() != nullptr;
}

USCS_Node* FComponentInfo_Default::GetSCSNode() const
{
	return SCSNode.Get();
}

FComponentInfo_Instanced::FComponentInfo_Instanced(AActor* Owner, UActorComponent* Component)
{
	InstancedComponentName = Component->GetFName();
	InstancedComponentOwnerPtr = Owner;
	Object = Component;
}

FName FComponentInfo_Instanced::GetVariableName() const
{
	return FComponentInfo::GetVariableName();
}

FText FComponentInfo_Instanced::GetDisplayText() const
{
	return FText::FromName(InstancedComponentName);
}

FHierarchyClassInfo::~FHierarchyClassInfo()
{
	if (bIsBlueprint && CompileDelegateHandle.IsValid() && Source.IsValid())
	{
		CastChecked<UBlueprint>(Source->ClassGeneratedBy)->OnCompiled().Remove(CompileDelegateHandle);
		CompileDelegateHandle.Reset();
	}
}

UClass* FBlueprintComponentReferenceHelper::FindClassByName(const FString& ClassName)
{
	UClass* Class =  UClass::TryFindTypeSlow<UClass>(ClassName, EFindFirstObjectOptions::EnsureIfAmbiguous);
	if (!Class)
	{
		Class = LoadObject<UClass>(nullptr, *ClassName);
	}
	return Class;
}

bool FBlueprintComponentReferenceHelper::GetHierarchyFromClass(const UClass* InClass, TArray<UClass*, TInlineAllocator<16>>& OutResult)
{
	OutResult.Reset();

	bool bNoErrors = true;
	UClass* CurrentClass = const_cast<UClass*>(InClass);
	while (CurrentClass)
	{
		OutResult.Add(CurrentClass);

		if (CurrentClass == AActor::StaticClass())
			break;

		if (UBlueprintGeneratedClass* CurrentBlueprintClass = Cast<UBlueprintGeneratedClass>(CurrentClass))
		{
#if WITH_EDITORONLY_DATA
			UBlueprint* BP = UBlueprint::GetBlueprintFromClass(CurrentBlueprintClass);

			if (BP)
			{
				bNoErrors &= (BP->Status != BS_Error);
			}

			// If valid, use stored ParentClass rather than the actual UClass::GetSuperClass(); handles the case when the class has not been recompiled yet after a reparent operation.
			if (BP && BP->ParentClass)
			{
				CurrentClass = Cast<UClass>(BP->ParentClass);
			}
			else
#endif
			{
				check(CurrentClass);
				CurrentClass = CurrentClass->GetSuperClass();
			}
		}
		else
		{
			check(CurrentClass);
			CurrentClass = CurrentClass->GetSuperClass();
		}
	}
	return bNoErrors;
}

FName FBlueprintComponentReferenceHelper::FindVariableForInstance(const UActorComponent* InstanceComponent, UClass* ClassToSearch)
{
	return FComponentEditorUtils::FindVariableNameGivenComponentInstance(InstanceComponent);
}

USCS_Node* FBlueprintComponentReferenceHelper::FindSCSNodeForInstance(const UActorComponent* InstanceComponent,UClass* ClassToSearch)
{
	if ((ClassToSearch != nullptr) && InstanceComponent->IsCreatedByConstructionScript())
	{
		for (UClass* TestClass = ClassToSearch; TestClass->ClassGeneratedBy != nullptr; TestClass = TestClass->GetSuperClass())
		{
			if (UBlueprint* TestBP = Cast<UBlueprint>(TestClass->ClassGeneratedBy))
			{
				if (TestBP->SimpleConstructionScript != nullptr)
				{
					if (USCS_Node* Result = TestBP->SimpleConstructionScript->FindSCSNode(InstanceComponent->GetFName()))
					{
						return Result;
					}
				}
			}
		}
	}

	return nullptr;
}

bool FBlueprintComponentReferenceHelper::DoesReferenceMatch(const FBlueprintComponentReference& InRef, const FComponentInfo& Value)
{
	if (InRef.Mode == EBlueprintComponentReferenceMode::Path)
		return InRef.Value == Value.GetObjectName();
	if (InRef.Mode == EBlueprintComponentReferenceMode::Property)
		return InRef.Value == Value.GetVariableName();
	return false;
}

TSharedPtr<FComponentInfo> FComponentPickerContext::FindComponent(const FBlueprintComponentReference& InName) const
{
	for (const auto& ClassDetails : ClassHierarchy)
	{
		for (const auto& Node : ClassDetails->GetNodes())
		{
			if ((FBlueprintComponentReferenceHelper::DoesReferenceMatch(InName, *Node)))
				return Node;
		}
	}

	return nullptr;
}

TSharedPtr<FComponentInfo> FComponentPickerContext::FindComponent(const FName& InName) const
{
	for (const auto& ClassDetails : ClassHierarchy)
	{
		for (const auto& Node : ClassDetails->GetNodes())
		{
			if (InName == Node->GetVariableName())
				return Node;
		}
	}

	return nullptr;
}

FBlueprintComponentReferenceHelper::FBlueprintComponentReferenceHelper()
{
	OnReloadCompleteDelegateHandle = FCoreUObjectDelegates::ReloadCompleteDelegate.AddRaw(this, &FBlueprintComponentReferenceHelper::OnReloadComplete);
	OnReloadReinstancingCompleteDelegateHandle = FCoreUObjectDelegates::ReloadReinstancingCompleteDelegate.AddRaw(this, &FBlueprintComponentReferenceHelper::OnReinstancingComplete);
	OnModulesChangedDelegateHandle = FModuleManager::Get().OnModulesChanged().AddRaw(this, &FBlueprintComponentReferenceHelper::OnModulesChanged);
}

FBlueprintComponentReferenceHelper::~FBlueprintComponentReferenceHelper()
{
	InstanceCache.Empty();
	ClassCache.Empty();

	FCoreUObjectDelegates::ReloadCompleteDelegate.Remove(OnReloadCompleteDelegateHandle);
	FCoreUObjectDelegates::ReloadReinstancingCompleteDelegate.Remove(OnReloadReinstancingCompleteDelegateHandle);
	FModuleManager::Get().OnModulesChanged().Remove(OnModulesChangedDelegateHandle);
}

bool FBlueprintComponentReferenceHelper::IsComponentReferenceProperty(const FProperty* InProperty)
{
	bool bDoesMatch = false;

	// todo: handle sets? but implementing GetTypeHash that will allow using BCR as map key
	if (auto AsStruct = CastField<FStructProperty>(InProperty))
	{
		bDoesMatch = IsComponentReferenceType(AsStruct->Struct);
	}
	else if (auto AsArray = CastField<FArrayProperty>(InProperty))
	{
		if (auto Inner = CastField<FStructProperty>(AsArray->Inner))
		{
			bDoesMatch = IsComponentReferenceType(Inner->Struct);
		}
	}
	else if (auto AsMap = CastField<FMapProperty>(InProperty))
	{
		if (auto Inner = CastField<FStructProperty>(AsMap->ValueProp))
		{
			bDoesMatch = IsComponentReferenceType(Inner->Struct);
		}
	}

	return bDoesMatch;
}

bool FBlueprintComponentReferenceHelper::IsComponentReferenceType(const UStruct* InStruct)
{
	return InStruct == FBlueprintComponentReference::StaticStruct();
}

TSharedPtr<FComponentPickerContext> FBlueprintComponentReferenceHelper::CreateChooserContext(AActor* InActor, UClass* InClass, const FString& InLabel)
{
	CleanupStaleData(false);

	if (!IsValid(InActor) && !IsValid(InClass))
	{ // we called from bad context that has no knowledge of owning class or blueprint
		return nullptr;
	}

	TSharedRef<FComponentPickerContext> Ctx = MakeShared<FComponentPickerContext>();
	Ctx->Label = InLabel;
	Ctx->Actor = InActor;
	Ctx->Class = InClass;

	UE_LOG(LogComponentReferenceEditor, Log, TEXT("%s Build for %s of type %s"), *Ctx->Label, *GetNameSafe(InActor), *GetNameSafe(InClass));

	if (auto InstanceData = GetOrCreateInstanceData(InLabel, InActor))
	{
		Ctx->ClassHierarchy.Add(InstanceData);
	}

	/**
	 * Record class hierarchy recursively.
 	 */
	{
		TArray<UClass*, TInlineAllocator<16>> Classes;
		GetHierarchyFromClass(Ctx->Class.Get(), Classes);

		for (auto* Class : Classes)
		{
			if (auto ClassData = GetOrCreateClassData(InLabel, Class))
			{
				Ctx->ClassHierarchy.Add(ClassData);
			}
		}
	}

	return Ctx;
}

void FBlueprintComponentReferenceHelper::CleanupStaleData(bool bForce)
{
	if (!bForce && (FPlatformTime::Seconds() - LastCacheCleanup ) < 0.2f)
	{
		return;
	}

	for(auto It = InstanceCache.CreateIterator(); It; ++It)
	{
		if (!It->Value->Source.IsValid())
		{
			It.RemoveCurrent();
			continue;
		}

		for (auto& Ptr : It->Value->Nodes)
		{
			if (!Ptr->GetComponentTemplate() || !Ptr->GetComponentClass())
			{
				It.RemoveCurrent();
				continue;
			}
		}
	}

	for(auto It = ClassCache.CreateIterator(); It; ++It)
	{
		if (!It->Value->Source.IsValid())
		{
			It.RemoveCurrent();
			continue;
		}

		for (auto& Ptr : It->Value->Nodes)
		{
			if (!Ptr->GetComponentTemplate() || !Ptr->GetComponentClass())
			{
				It.RemoveCurrent();
				continue;
			}
		}
	}

	LastCacheCleanup = FPlatformTime::Seconds();
}

TSharedPtr<FHierarchyInfo> FBlueprintComponentReferenceHelper::GetOrCreateInstanceData(FString const& InLabel, AActor* InActor)
{
	const FInstanceKey EntryKey { GetFNameSafe(InActor->GetWorld()), GetFNameSafe(InActor), GetFNameSafe(InActor->GetClass())  };

	TSharedPtr<FHierarchyInstanceInfo>  Entry;

	if (auto* FoundExisting = InstanceCache.Find(EntryKey))
	{
		Entry = *FoundExisting;
	}
	else
	{
		if (!InActor->IsTemplate())
		{
			TInlineComponentArray<UActorComponent*> Components;
			InActor->GetComponents(Components);

			Entry = InstanceCache.Emplace(EntryKey, MakeShared<FHierarchyInstanceInfo>());
			for (UActorComponent* Object : Components)
			{
				if (Object->CreationMethod == EComponentCreationMethod::Instance)
				{
					UE_LOG(LogComponentReferenceEditor, Log, TEXT("%s register INS node %s"), *InLabel, *BuildComponentInfo(Object));
					Entry->Nodes.Add(CreateFromInstance(Object));
				}
			}
		}
		else
		{
			// tbd?
		}
	}

	return Entry;
}

TSharedPtr<FHierarchyInfo> FBlueprintComponentReferenceHelper::GetOrCreateClassData(FString const& InLabel, UClass* InClass)
{
	const FClassKey EntryKey { GetFNameSafe(InClass->GetOuter()) , GetFNameSafe(InClass) };

	TSharedPtr<FHierarchyClassInfo>  Entry;

	if (auto* FoundExisting = ClassCache.Find(EntryKey))
	{
		Entry = *FoundExisting;
	}
	else
	{
		Entry = ClassCache.Emplace(EntryKey, MakeShared<FHierarchyClassInfo>());
		Entry->Source = InClass;
		Entry->ClassDisplayText = InClass->GetDisplayNameText();

		/**
		 * If we looking a blueprint - skim its construction script for components
		 */
		if (auto BPClass = Entry->GetClass<UBlueprintGeneratedClass>())
		{
			Entry->bIsBlueprint = true;

			if (auto Blueprint = Cast<UBlueprint>(BPClass->ClassGeneratedBy))
			{
				Entry->CompileDelegateHandle = Blueprint->OnCompiled().AddRaw(this, &FBlueprintComponentReferenceHelper::OnBlueprintCompiled, Entry);
			}

			for(USCS_Node* SCSNode : BPClass->SimpleConstructionScript->GetAllNodes())
			{
				auto Template = SCSNode->GetActualComponentTemplate(BPClass);
				UE_LOG(LogComponentReferenceEditor, Log, TEXT("%s register BPR node %s"), *InLabel, *BuildComponentInfo(Template));

				Entry->Nodes.Add(CreateFromNode(SCSNode));
			}
		}
		/**
		 * If we looking a native class - look in default subobjects
		 */
		else if (auto NtClass = Entry->GetClass<UClass>())
		{
			TInlineComponentArray<UActorComponent*> Components;
			NtClass->GetDefaultObject<AActor>()->GetComponents(Components);

			for (UActorComponent* Object : Components)
			{
				UE_LOG(LogComponentReferenceEditor, Log, TEXT("%s register NAT node %s"), *InLabel, *BuildComponentInfo(Object));

				Entry->Nodes.Add(CreateFromInstance(Object));
			}
		}
	}


	return Entry;
}


TSharedPtr<FComponentInfo> FBlueprintComponentReferenceHelper::CreateFromNode(USCS_Node* InComponentNode)
{
	check(InComponentNode);
	return MakeShared<FComponentInfo_Default>(InComponentNode);
}

TSharedPtr<FComponentInfo> FBlueprintComponentReferenceHelper::CreateFromInstance(UActorComponent* InComponent)
{
	check(InComponent);

	AActor* Owner = InComponent->GetOwner();
	if (IsValid(Owner) && !Owner->IsTemplate())
	{
		return MakeShared<FComponentInfo_Instanced>(Owner, InComponent);
	}

	return MakeShared<FComponentInfo_Default>(InComponent);
}

bool FBlueprintComponentReferenceHelper::IsBlueprintProperty(const FProperty* VariableProperty)
{
	if(UClass* const VarSourceClass = VariableProperty ? VariableProperty->GetOwner<UClass>() : NULL)
	{
		return (VarSourceClass->ClassGeneratedBy != NULL);
	}
	return false;
}

bool FBlueprintComponentReferenceHelper::HasMetaDataValue(const FProperty* Property, const FName& InName)
{
	return Property->HasMetaData(InName);
}

TOptional<bool> FBlueprintComponentReferenceHelper::GetBoolMetaDataOptional(const FProperty* Property, const FName& InName)
{
	if (Property->HasMetaData(InName))
	{
		bool bResult = true;

		const FString& ValueString = Property->GetMetaData(InName);
		if (!ValueString.IsEmpty())
		{
			if (ValueString == TEXT("true"))
			{
				bResult = true;
			}
			else if (ValueString == TEXT("false"))
			{
				bResult = false;
			}
		}

		return TOptional<bool>(bResult);
	}

	return TOptional<bool>();
}

bool FBlueprintComponentReferenceHelper::GetBoolMetaDataValue(const FProperty* Property, const FName& InName, bool bDefaultValue)
{
	bool bResult = bDefaultValue;

	if (Property->HasMetaData(InName))
	{
		bResult = true;

		const FString& ValueString = Property->GetMetaData(InName);
		if (!ValueString.IsEmpty())
		{
			if (ValueString == TEXT("true"))
			{
				bResult = true;
			}
			else if (ValueString == TEXT("false"))
			{
				bResult = false;
			}
		}
	}

	return bResult;
}

void FBlueprintComponentReferenceHelper::SetBoolMetaDataValue(FProperty* Property, const FName& InName, TOptional<bool> Value)
{
	if (Value.IsSet())
	{
		Property->SetMetaData(InName, Value.GetValue() ? TEXT("true") : TEXT("false"));
	}
	else
	{
		Property->RemoveMetaData(InName);
	}

	if (UObject* ParamOwner = Property->GetOwnerUObject())
	{
		ParamOwner->Modify();
	}
}

void FBlueprintComponentReferenceHelper::GetClassListMetadata(const FProperty* Property, const FName& InName, const TFunctionRef<void(UClass*)>& Func)
{
	const FString& MetaDataString = Property->GetMetaData(InName);
	if (MetaDataString.IsEmpty())
	{
		return;
	}

	TArray<FString> ClassFilterNames;
	MetaDataString.ParseIntoArrayWS(ClassFilterNames, TEXT(","), true);

	for (const FString& ClassName : ClassFilterNames)
	{
		if (UClass* Class = FBlueprintComponentReferenceHelper::FindClassByName(ClassName))
		{
			// If the class is an interface, expand it to be all classes in memory that implement the class.
			if (Class->HasAnyClassFlags(CLASS_Interface))
			{
				for (TObjectIterator<UClass> ClassIt; ClassIt; ++ClassIt)
				{
					UClass* const ClassWithInterface = (*ClassIt);
					if (ClassWithInterface->IsChildOf(UActorComponent::StaticClass()) && ClassWithInterface->ImplementsInterface(Class))
					{
						Func(ClassWithInterface);
					}
				}
			}
			else if (Class->IsChildOf(UActorComponent::StaticClass()))
			{
				Func(Class);
			}
		}
	}
}

void FBlueprintComponentReferenceHelper::SetClassListMetadata(FProperty* Property, const FName& InName, const TFunctionRef<void(TArray<FString>&)>& PathSource)
{
	TArray<FString> Result;
	PathSource(Result);

	FString Complete = FString::Join(Result, TEXT(","));
	if (Complete.IsEmpty())
	{
		Property->RemoveMetaData(InName);
	}
	else
	{
		Property->SetMetaData(InName, MoveTemp(Complete));
	}

	if (UObject* ParamOwner = Property->GetOwnerUObject())
	{
		ParamOwner->Modify();
	}
}

void FBlueprintComponentReferenceHelper::OnReloadComplete(EReloadCompleteReason ReloadCompleteReason)
{
	UE_LOG(LogComponentReferenceEditor, Log, TEXT("OnReloadComplete"));
}

void FBlueprintComponentReferenceHelper::OnReinstancingComplete()
{
	UE_LOG(LogComponentReferenceEditor, Log, TEXT("OnReinstancingComplete"));
}

void FBlueprintComponentReferenceHelper::OnModulesChanged(FName Name, EModuleChangeReason ModuleChangeReason)
{
	UE_LOG(LogComponentReferenceEditor, Log, TEXT("OnModulesChanged"));
}

void FBlueprintComponentReferenceHelper::OnObjectReloaded(UObject* Object)
{
	UE_LOG(LogComponentReferenceEditor, Log, TEXT("OnObjectReloaded"));
}

void FBlueprintComponentReferenceHelper::OnBlueprintCompiled(UBlueprint* Blueprint, TSharedPtr<FHierarchyClassInfo> Entry)
{
	UE_LOG(LogComponentReferenceEditor, Log, TEXT("OnBlueprintCompiled"));
}


#undef LOCTEXT_NAMESPACE
